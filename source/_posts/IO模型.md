---
title: IO模型
date: 2020-07-14 10:28:28
tags:
  - IO模型
---

#### 同步阻塞

当对面Socket来了IO请求的时候，对面的Socket在等(同步)，我也在准备数据，准备了一段时间(阻塞)准备好了返回给对方

#### 同步非阻塞

当对面Socket来了IO请求的时候，对面的Socket在等(同步)，我还没准备好，就先返回给对面Error，对面一看Error知道我还没准备好，他就去做别的事情了(非阻塞)，等过段时间再来询问。

#### 异步阻塞(IO多路复用)

I/O 多路复用模型是利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。

当用户进程Socket调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的用户Socket，当任何一个Socket中的数据准备好了，select就会返回。等用户进程再调用read操作，将数据从kernel拷贝到用户进程。

这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。异步指的是Socket请求后就去做别的事情了，下次再来read的时候对面数据就准备好了。

下面举一个例子，模拟一个tcp服务器处理30个客户socket。
假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：

\1. 第一种选择：**按顺序逐个检查**，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误。
这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。
\2. 第二种选择：你**创建30个分身**，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。
\3. 第三种选择，你**站在讲台上等，谁解答完谁举手**。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。 
这种就是IO复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达(poll是全部轮询一遍，epoll只轮询那些真正发出了事件的流)，这样就避免了大量的无用操作。此时的socket应该采用**非阻塞模式**。
这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的(因为用户Socket下次来的时候数据已经准备好了)，整个进程或者线程就被充分利用起来，这就是**事件驱动**，所谓的reactor模式

#### 异步非阻塞

在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。(同步的话是等着用户线程下次再来询问)也就说用户线程完全不需要关心实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。